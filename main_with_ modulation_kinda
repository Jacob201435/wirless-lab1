/**
 * main.c - DAC with Sine Wave Generation and Digital Modulation
 * CSE-4377 Lab 1
 */
#include <stdlib.h>
#include <stdint.h>
#include <stdbool.h>
#include <math.h>
#include "tm4c123gh6pm.h"
#include "clock80.h"
#include "gpio.h"
#include "nvic.h"
#include "spi1.h"
#include "wait.h"
#include "uart0.h"
#include "string.h"

// LDAC Bitband Alias
#define LDAC (*((volatile uint32_t *)(0x42000000 + (0x400063FC-0x40000000)*32 + 4*4)))

// DAC Control Constants
#define DAC_A 0x3000  // DAC A (I channel)
#define DAC_B 0xB000  // DAC B (Q channel)

// Constants
#define FCYC 80e6
#define FDAC 20e6
#define LUT_SIZE 256
#define PI 3.14159265358979323846

// Gains and Offsets (from your calibration)
#define GAIN_I 1977
#define GAIN_Q 1972
#define OFS_I 2120
#define OFS_Q 2078

USER_DATA data; // Global variable for UART command parsing

// Mode control
typedef enum
{
    MODE_STATIC,
    MODE_SINE,
    MODE_STREAM
} OperationMode;

OperationMode currentMode = MODE_STATIC;    // Start in static mode

// Sine wave lookup table
int16_t sine_LUT[LUT_SIZE];
int16_t cosine_LUT[LUT_SIZE];
uint16_t lut_index = 0;

int32_t i_value = OFS_I;  // Default to mid-scale
int32_t q_value = OFS_Q;  // Default to mid-scale

typedef enum
{
    MOD_BPSK  = 1,
    MOD_QPSK  = 2,
    MOD_8PSK  = 3,
    MOD_16QAM = 4
} ModType;

volatile ModType modType = MOD_QPSK;

#define STREAM_MAX 1024                     // Max symbols in stream
volatile uint8_t symbolStream[STREAM_MAX];  // Symbol stream
volatile uint32_t symbolCount = 0;          // Number of symbols currently in stream
volatile uint32_t symbolIndex = 0;          // Index of next symbol to output

// Rates
volatile uint32_t sampleRateHz = 2560000;   // Computed from timer
volatile uint32_t symbolRate   = 1000;      // Symbols/sec
volatile uint32_t samplesPerSymbol = 2560;  // sampleRateHz / symbolRate
volatile uint32_t spsCount = 0;

// Current baseband symbol (signed)
volatile int32_t stream_i = 0;
volatile int32_t stream_q = 0;

// BPSK
static const int16_t bpskI[2] = { +GAIN_I, -GAIN_I };
static const int16_t bpskQ[2] = { 0, 0 };

// QPSK (Gray-coded: 00,01,11,10)
static const int16_t qpskI[4] = { +GAIN_I, -GAIN_I, -GAIN_I, +GAIN_I };
static const int16_t qpskQ[4] = { +GAIN_Q, +GAIN_Q, -GAIN_Q, -GAIN_Q };

// 8PSK (0,45,90,135,180,225,270,315 degrees)
static const int16_t psk8I[8] =
{
    (int16_t)(+1.000f * GAIN_I),    // 0 degrees
    (int16_t)(+0.707f * GAIN_I),    // 45 degrees
    (int16_t)(+0.000f * GAIN_I),    // 90 degrees
    (int16_t)(-0.707f * GAIN_I),    // 135 degrees
    (int16_t)(-1.000f * GAIN_I),    // 180 degrees
    (int16_t)(-0.707f * GAIN_I),    // 225 degrees
    (int16_t)(+0.000f * GAIN_I),    // 270 degrees
    (int16_t)(+0.707f * GAIN_I)     // 315 degrees
};
static const int16_t psk8Q[8] =
{
    (int16_t)(+0.000f * GAIN_Q),    // 0 degrees
    (int16_t)(+0.707f * GAIN_Q),    // 45 degrees
    (int16_t)(+1.000f * GAIN_Q),    // 90 degrees
    (int16_t)(+0.707f * GAIN_Q),    // 135 degrees
    (int16_t)(+0.000f * GAIN_Q),    // 180 degrees
    (int16_t)(-0.707f * GAIN_Q),    // 225 degrees
    (int16_t)(-1.000f * GAIN_Q),    // 270 degrees
    (int16_t)(-0.707f * GAIN_Q)     // 315 degrees
};

// 16QAM grid: I,Q e {-3,-1,+1,+3} (Gray-coded per axis)
#define QAM_SCALE_I (GAIN_I / 3)
#define QAM_SCALE_Q (GAIN_Q / 3)
static const int8_t gray2level[4] = { -3, -1, +3, +1 }; // 00->-3, 01->-1, 11->+3, 10->+1

static inline int16_t qam16I_fromSym(uint8_t sym)
{
    uint8_t iBits = (sym >> 2) & 0x3;
    return (int16_t)(gray2level[iBits] * QAM_SCALE_I);
}

static inline int16_t qam16Q_fromSym(uint8_t sym)
{
    uint8_t qBits = sym & 0x3;
    return (int16_t)(gray2level[qBits] * QAM_SCALE_Q);
}

//-----------------------------------------------------------------------------
// Update rate calculations
//-----------------------------------------------------------------------------
void updateRates(void)
{
    // Calculate actual sample rate from timer
    uint32_t timer_load = TIMER1_TAILR_R + 1;
    sampleRateHz = 80000000u / timer_load;

    // Calculate samples per symbol
    if (symbolRate > 0)
        samplesPerSymbol = sampleRateHz / symbolRate;
    else
        samplesPerSymbol = 1000; // Default

    // Reset counter
    spsCount = samplesPerSymbol;
}

//-----------------------------------------------------------------------------
// Generate Sine/Cosine Lookup Tables
//-----------------------------------------------------------------------------
void generateLUT()
{
    int i;
    for (i = 0; i < LUT_SIZE; i++)
    {
        float angle = (2.0f * (float)PI * (float)i) / (float)LUT_SIZE;
        cosine_LUT[i] = (int16_t)(cosf(angle) * (float)GAIN_I);
        sine_LUT[i]   = (int16_t)(sinf(angle) * (float)GAIN_Q);
    }
}

//-----------------------------------------------------------------------------
// Simple integer to string converter
//-----------------------------------------------------------------------------
void intToStr(int32_t value, char* buffer)
{
    int pos = 0;
    int temp;
    char rev[20];
    int rpos = 0;

    if (value == 0)
    {
        buffer[0] = '0';
        buffer[1] = '\0';
        return;
    }

    if (value < 0)
    {
        buffer[pos++] = '-';
        value = -value;
    }

    temp = value;
    while (temp > 0)
    {
        rev[rpos++] = '0' + (temp % 10);
        temp /= 10;
    }

    while (rpos > 0)
    {
        buffer[pos++] = rev[--rpos];
    }

    buffer[pos] = '\0';
}

//-----------------------------------------------------------------------------
// Timer ISR - Outputs I and Q values to DAC
//-----------------------------------------------------------------------------
void timer1Isr()
{
    uint16_t command;
    int32_t dac_i = OFS_I;
    int32_t dac_q = OFS_Q;

    if (currentMode == MODE_SINE)
    {
        // I = cosine, Q = sine
        dac_i = cosine_LUT[lut_index] + OFS_I;
        dac_q = sine_LUT[lut_index]   + OFS_Q;

        // Increment index for next sample
        lut_index++;
        if (lut_index >= LUT_SIZE)
            lut_index = 0;
    }
    else if (currentMode == MODE_STREAM)
    {
        // Reload counter if needed
        if (spsCount == 0)
            spsCount = samplesPerSymbol;

        // Load a NEW symbol only at the start of the hold period
        if (spsCount == samplesPerSymbol)
        {
            // Check if we have symbols to transmit
            if (symbolCount > 0)
            {
                uint8_t sym = symbolStream[symbolIndex];

                switch (modType)
                {
                    case MOD_BPSK:
                        stream_i = bpskI[sym & 0x01];  // Only use bit 0
                        stream_q = bpskQ[sym & 0x01];
                        break;

                    case MOD_QPSK:
                        stream_i = qpskI[sym & 0x03];  // Use bits 0-1
                        stream_q = qpskQ[sym & 0x03];
                        break;

                    case MOD_8PSK:
                        stream_i = psk8I[sym & 0x07];  // Use bits 0-2
                        stream_q = psk8Q[sym & 0x07];
                        break;

                    case MOD_16QAM:
                        stream_i = qam16I_fromSym(sym & 0x0F);  // Use bits 0-3
                        stream_q = qam16Q_fromSym(sym & 0x0F);
                        break;

                    default:
                        stream_i = 0;
                        stream_q = 0;
                        break;
                }

                // Advance to next symbol (wrap)
                symbolIndex++;
                if (symbolIndex >= symbolCount)
                    symbolIndex = 0;
            }
            else
            {
                // No symbols - output zero
                stream_i = 0;
                stream_q = 0;
            }
        }

        // Decrement sample hold counter
        spsCount--;

        // Output current symbol (baseband deviation + offset)
        dac_i = stream_i + OFS_I;
        dac_q = stream_q + OFS_Q;
    }
    else
    {
        // Static mode - use set values
        dac_i = i_value;
        dac_q = q_value;
    }

    // Clamp to 12-bit range
    if (dac_i < 0) dac_i = 0;
    if (dac_i > 4095) dac_i = 4095;
    if (dac_q < 0) dac_q = 0;
    if (dac_q > 4095) dac_q = 4095;

    // Toggle LDAC to latch data
    LDAC = 0;
    LDAC = 1;

    // Send I value to DAC A
    command = DAC_A | (dac_i & 0x0FFF);
    SSI1_DR_R = command;
    while (SSI1_SR_R & SSI_SR_BSY);

    // Send Q value to DAC B
    command = DAC_B | (dac_q & 0x0FFF);
    SSI1_DR_R = command;
    while (SSI1_SR_R & SSI_SR_BSY);

    // Clear interrupt flag
    TIMER1_ICR_R = TIMER_ICR_TATOCINT;
}

//-----------------------------------------------------------------------------
// Convert text string to symbol stream
//-----------------------------------------------------------------------------
void textToSymbols(const char* text)
{
    uint8_t bitsPerSymbol;

    // Determine bits per symbol
    switch (modType)
    {
        case MOD_BPSK:  bitsPerSymbol = 1; break;
        case MOD_QPSK:  bitsPerSymbol = 2; break;
        case MOD_8PSK:  bitsPerSymbol = 3; break;
        case MOD_16QAM: bitsPerSymbol = 4; break;
        default: bitsPerSymbol = 1;
    }

    symbolCount = 0;
    uint8_t bitBuffer = 0;
    uint8_t bitCount = 0;

    // Convert each character to bits, then pack into symbols
    uint32_t i;
    for (i = 0; text[i] != '\0' && symbolCount < STREAM_MAX; i++)
    {
        uint8_t c = (uint8_t)text[i];

        // Process each bit in the character (MSB first)
        int8_t bit;
        for (bit = 7; bit >= 0; bit--)
        {
            // Extract bit
            bitBuffer = (bitBuffer << 1) | ((c >> bit) & 0x01);
            bitCount++;

            // When we have enough bits for a symbol, store it
            if (bitCount == bitsPerSymbol)
            {
                symbolStream[symbolCount++] = bitBuffer;
                bitBuffer = 0;
                bitCount = 0;

                if (symbolCount >= STREAM_MAX)
                    break;
            }
        }
    }

    // If there are leftover bits, pad and store
    if (bitCount > 0 && symbolCount < STREAM_MAX)
    {
        // Pad with zeros
        bitBuffer <<= (bitsPerSymbol - bitCount);
        symbolStream[symbolCount++] = bitBuffer;
    }

    // Reset symbol index
    symbolIndex = 0;
    spsCount = samplesPerSymbol;
}

//-----------------------------------------------------------------------------
// Command Handler
//-----------------------------------------------------------------------------
void handleCommand()
{
    char buffer[20];

    getsUart0(&data);
    parseFields(&data);

    if (isCommand(&data, "set", 2))
    {
        currentMode = MODE_STATIC;
        i_value = getFieldInteger(&data, 1);
        q_value = getFieldInteger(&data, 2);

        if (i_value < 0) i_value = 0;
        if (i_value > 4095) i_value = 4095;
        if (q_value < 0) q_value = 0;
        if (q_value > 4095) q_value = 4095;

        putsUart0("\rDAC values set: I=");
        intToStr(i_value, buffer);
        putsUart0(buffer);
        putsUart0(", Q=");
        intToStr(q_value, buffer);
        putsUart0(buffer);
        putsUart0("\n");
    }
    else if (isCommand(&data, "sine", 0))
    {
        currentMode = MODE_SINE;
        lut_index = 0;
        putsUart0("\rSwitched to SINE wave mode\n");
        putsUart0("\rI = cosine, Q = sine\n");
    }
    else if (isCommand(&data, "static", 0))
    {
        currentMode = MODE_STATIC;
        putsUart0("\rSwitched to STATIC mode\n");
    }
    else if (isCommand(&data, "mid", 0))
    {
        currentMode = MODE_STATIC;
        i_value = OFS_I;
        q_value = OFS_Q;
        putsUart0("\rSet to mid-scale (offset values)\n");
    }
    else if (isCommand(&data, "min", 0))
    {
        currentMode = MODE_STATIC;
        i_value = 0;
        q_value = 0;
        putsUart0("\rSet to minimum: I=0, Q=0\n");
    }
    else if (isCommand(&data, "max", 0))
    {
        currentMode = MODE_STATIC;
        i_value = 4095;
        q_value = 4095;
        putsUart0("\rSet to maximum: I=4095, Q=4095\n");
    }
    else if (isCommand(&data, "i", 1))
    {
        currentMode = MODE_STATIC;
        i_value = getFieldInteger(&data, 1);
        if (i_value < 0) i_value = 0;
        if (i_value > 4095) i_value = 4095;

        putsUart0("\rI channel set to: ");
        intToStr(i_value, buffer);
        putsUart0(buffer);
        putsUart0("\n");
    }
    else if (isCommand(&data, "q", 1))
    {
        currentMode = MODE_STATIC;
        q_value = getFieldInteger(&data, 1);
        if (q_value < 0) q_value = 0;
        if (q_value > 4095) q_value = 4095;

        putsUart0("\rQ channel set to: ");
        intToStr(q_value, buffer);
        putsUart0(buffer);
        putsUart0("\n");
    }
    else if (isCommand(&data, "start", 0))
    {
        TIMER1_CTL_R |= TIMER_CTL_TAEN;
        putsUart0("\rDAC output started\n");
    }
    else if (isCommand(&data, "stop", 0))
    {
        TIMER1_CTL_R &= ~TIMER_CTL_TAEN;
        putsUart0("\rDAC output stopped\n");
    }
    else if (isCommand(&data, "freq", 1))
    {
        uint32_t freq = (uint32_t)getFieldInteger(&data, 1);

        if (freq < 1 || freq > 100000)
        {
            putsUart0("\rFrequency must be 1-100000 Hz\n");
            return;
        }

        uint32_t sample_rate = freq * LUT_SIZE;
        uint32_t timer_load = 80000000u / sample_rate;

        if (timer_load < 2) timer_load = 2;

        TIMER1_TAILR_R = timer_load - 1;

        // Update stream timing
        updateRates();

        putsUart0("\rFrequency set to: ");
        intToStr((int32_t)freq, buffer);
        putsUart0(buffer);
        putsUart0(" Hz\n");
    }
    // -------------------- Modulation Commands --------------------
    else if (isCommand(&data, "mod", 1))
    {
        char *m = getFieldString(&data, 1);

        if      (strcmp(m, "bpsk") == 0)  modType = MOD_BPSK;
        else if (strcmp(m, "qpsk") == 0)  modType = MOD_QPSK;
        else if (strcmp(m, "psk8") == 0)  modType = MOD_8PSK;
        else if (strcmp(m, "qam16") == 0) modType = MOD_16QAM;
        else
        {
            putsUart0("\rUse: mod bpsk|qpsk|psk8|qam16\n");
            return;
        }

        putsUart0("\rModulation set to: ");
        putsUart0(m);
        putsUart0("\n");
    }
    else if (isCommand(&data, "sym", 1))
    {
        uint32_t rate = (uint32_t)getFieldInteger(&data, 1);

        if (rate < 1 || rate > 100000)
        {
            putsUart0("\rSymbol rate must be 1-100000 symbols/sec\n");
            return;
        }

        symbolRate = rate;
        updateRates();

        putsUart0("\rSymbol rate set to: ");
        intToStr((int32_t)symbolRate, buffer);
        putsUart0(buffer);
        putsUart0(" symbols/sec\n");

        putsUart0("\r(Samples per symbol: ");
        intToStr((int32_t)samplesPerSymbol, buffer);
        putsUart0(buffer);
        putsUart0(")\n");
    }
    else if (isCommand(&data, "stream", 1))
    {
        char* text = getFieldString(&data, 1);

        // Convert text to symbols
        textToSymbols(text);

        // Switch to stream mode
        currentMode = MODE_STREAM;
        symbolIndex = 0;
        spsCount = samplesPerSymbol;

        putsUart0("\rStream loaded: ");
        intToStr((int32_t)symbolCount, buffer);
        putsUart0(buffer);
        putsUart0(" symbols\n");
    }
    // -------------------- Help --------------------
    else if (isCommand(&data, "help", 0))
    {
        putsUart0("\r\n=== CSE-4377 Lab 1 Commands ===\n");
        putsUart0("\rset <I> <Q>  - Set both channels (0-4095)\n");
        putsUart0("\ri <value>    - Set I channel only (0-4095)\n");
        putsUart0("\rq <value>    - Set Q channel only (0-4095)\n");
        putsUart0("\rmid          - Set to calibrated mid-scale\n");
        putsUart0("\rmin          - Set to minimum (0, 0)\n");
        putsUart0("\rmax          - Set to maximum (4095, 4095)\n");
        putsUart0("\rsine         - Sine tone (I=cos, Q=sin)\n");
        putsUart0("\rstatic       - Return to static mode\n");
        putsUart0("\rfreq <Hz>    - Set sine frequency (1-100000 Hz)\n");
        putsUart0("\rstart        - Start DAC output\n");
        putsUart0("\rstop         - Stop DAC output\n");

        putsUart0("\r\n--- Digital Modulation ---\n");
        putsUart0("\rmod <type>    - Set modulation (bpsk|qpsk|psk8|qam16)\n");
        putsUart0("\rsym <rate>    - Set symbol rate (symbols/sec)\n");
        putsUart0("\rstream <text> - Load text and start streaming\n");
        putsUart0("\r                Example: stream Hello\n");

        putsUart0("\r\nCalibration values:\n");
        putsUart0("\r  GAIN_I=");
        intToStr(GAIN_I, buffer);
        putsUart0(buffer);
        putsUart0(", GAIN_Q=");
        intToStr(GAIN_Q, buffer);
        putsUart0(buffer);
        putsUart0("\r\n  OFS_I=");
        intToStr(OFS_I, buffer);
        putsUart0(buffer);
        putsUart0(", OFS_Q=");
        intToStr(OFS_Q, buffer);
        putsUart0(buffer);
        putsUart0("\r\n\n");
    }
    else
    {
        putsUart0("\rUnknown command. Type 'help' for options.\n");
    }
}

//-----------------------------------------------------------------------------
// Hardware Initialization
//-----------------------------------------------------------------------------
void initHW()
{
    // Initialize system clock to 80 MHz
    initSystemClockTo80Mhz();

    // Enable Ports
    SYSCTL_RCGCTIMER_R |= SYSCTL_RCGCTIMER_R1;
    enablePort(PORTC);
    enablePort(PORTD);

    // Enable Timer
    // For 10 kHz sine wave with 256-point LUT, we need 2.56 MHz sample rate
    // Timer period = 80MHz / 2.56MHz = 31.25 = 31
    TIMER1_CTL_R &= ~TIMER_CTL_TAEN;                 // Turn off timer
    TIMER1_CFG_R = TIMER_CFG_32_BIT_TIMER;           // 32-bit timer
    TIMER1_TAMR_R = TIMER_TAMR_TAMR_PERIOD;          // Periodic mode
    TIMER1_TAILR_R = 31;                             // 2.58 MHz sample rate
    TIMER1_IMR_R = TIMER_IMR_TATOIM;                 // Enable interrupts
    NVIC_EN0_R = 1 << (INT_TIMER1A-16);              // Enable interrupt 37

    // Configure LDAC pin
    selectPinPushPullOutput(PORTC, 4);

    // Initialize SPI
    initSpi1(USE_SSI_FSS);
    setSpi1BaudRate(FDAC, 80e6);

    // Calculate initial rates
    updateRates();
}

//-----------------------------------------------------------------------------
// Main
//-----------------------------------------------------------------------------
int main(void)
{
    // Initialize hardware
    initHW();
    initUart0();
    setUart0BaudRate(115200, 80e6);

    // Generate lookup tables
    generateLUT();

    // Startup message
    putsUart0("\r\n\n");
    putsUart0("\r========================================\n");
    putsUart0("\r  CSE-4377 Lab 1 - IQ Modulation\n");
    putsUart0("\r========================================\n");
    putsUart0("\r\nType 'help' for available commands\n");
    putsUart0("\r\nQuick start:\n");
    putsUart0("\r  1. mod qpsk\n");
    putsUart0("\r  2. sym 1000\n");
    putsUart0("\r  3. stream Hello\n");
    putsUart0("\r  4. start\n\n");

    // Main loop
    while (true)
    {
        if (kbhitUart0())
        {
            handleCommand();
        }
    }
}
