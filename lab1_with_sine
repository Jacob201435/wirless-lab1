/**
 * main.c - DAC with Sine Wave Generation
 * CSE-4377 Lab 1
 */
#include <stdlib.h>
#include <stdint.h>
#include <stdbool.h>
#include <math.h>
#include "tm4c123gh6pm.h"
#include "clock80.h"
#include "gpio.h"
#include "nvic.h"
#include "spi1.h"
#include "wait.h"
#include "uart0.h"
#include "string.h"

// LDAC Bitband Alias
#define LDAC (*((volatile uint32_t *)(0x42000000 + (0x400063FC-0x40000000)*32 + 4*4)))

// DAC Control Constants
#define DAC_A 0x3000  // DAC A (I channel)
#define DAC_B 0xB000  // DAC B (Q channel)

// Constants
#define FCYC 80e6
#define FDAC 20e6
#define LUT_SIZE 256
#define PI 3.14159265358979323846

// Gains and Offsets (from your calibration)
#define GAIN_I 1977
#define GAIN_Q 1972
#define OFS_I 2120
#define OFS_Q 2078

// Global variables for DAC values
int32_t i_value = 2048;  // Start at mid-scale (0V)
int32_t q_value = 2048;  // Start at mid-scale (0V)

// Mode control
typedef enum {
    MODE_STATIC,    // Static I/Q values
    MODE_SINE       // Generate sine wave
} OperationMode;

OperationMode currentMode = MODE_STATIC;

// Phase accumulator for precise frequency control
uint32_t phase_accumulator = 0;  // 32-bit accumulator
uint32_t phase_increment = 0;    // How much to add each sample

USER_DATA data;

// Sine wave lookup table
int16_t sine_LUT[LUT_SIZE];
int16_t cosine_LUT[LUT_SIZE];
uint16_t lut_index = 0;

//-----------------------------------------------------------------------------
// Generate Sine/Cosine Lookup Tables
//-----------------------------------------------------------------------------
void generateLUT()
{
    int i;
    for (i = 0; i < LUT_SIZE; i++)
    {
        float angle = (2.0 * PI * i) / LUT_SIZE;  // Map index to angle
        float sin_value = sinf(angle);  // Generate sine wave value (-1 to +1)
        float cos_value = cosf(angle);  // Generate cosine wave value (-1 to +1)

        // Scale by gain to get proper amplitude
        // sin_value and cos_value are -1 to +1
        // Multiply by GAIN to get the deviation from center
        sine_LUT[i] = (int16_t)(sin_value * GAIN_I);
        cosine_LUT[i] = (int16_t)(cos_value * GAIN_Q);
    }
}

//-----------------------------------------------------------------------------
// Timer ISR - Outputs I and Q values to DAC
//-----------------------------------------------------------------------------
void timer1Isr()
{
    uint16_t command;
    int32_t dac_i, dac_q;

    // Toggle LDAC to latch data
    LDAC = 0;
    LDAC = 1;

    if (currentMode == MODE_SINE)
    {
        // Generate sine wave using phase accumulator
        // Upper 8 bits of phase_accumulator index into 256-entry LUT
        uint8_t lut_index = phase_accumulator >> 24;

        // I channel gets cosine (In-phase, 0°)
        // Q channel gets sine (Quadrature, 90°)
        dac_i = cosine_LUT[lut_index] + OFS_I;
        dac_q = sine_LUT[lut_index] + OFS_Q;

        // Increment phase accumulator
        phase_accumulator += phase_increment;
        // Automatically wraps at 2^32
    }
    else
    {
        // Static mode - use set values
        dac_i = i_value;
        dac_q = q_value;
    }

    // Clamp to 12-bit range
    if (dac_i < 0) dac_i = 0;
    if (dac_i > 4095) dac_i = 4095;
    if (dac_q < 0) dac_q = 0;
    if (dac_q > 4095) dac_q = 4095;

    // Send I value to DAC A
    command = DAC_A | (dac_i & 0x0FFF);
    SSI1_DR_R = command;
    while (SSI1_SR_R & SSI_SR_BSY);

    // Send Q value to DAC B
    command = DAC_B | (dac_q & 0x0FFF);
    SSI1_DR_R = command;
    while (SSI1_SR_R & SSI_SR_BSY);

    // Clear interrupt flag
    TIMER1_ICR_R = TIMER_ICR_TATOCINT;
}

//-----------------------------------------------------------------------------
// Simple integer to string converter
//-----------------------------------------------------------------------------
void intToStr(int32_t value, char* buffer)
{
    int pos = 0;
    int temp;
    char rev[20];
    int rpos = 0;

    if (value == 0)
    {
        buffer[0] = '0';
        buffer[1] = '\0';
        return;
    }

    if (value < 0)
    {
        buffer[pos++] = '-';
        value = -value;
    }

    temp = value;
    while (temp > 0)
    {
        rev[rpos++] = '0' + (temp % 10);
        temp /= 10;
    }

    while (rpos > 0)
    {
        buffer[pos++] = rev[--rpos];
    }

    buffer[pos] = '\0';
}

//-----------------------------------------------------------------------------
// Command Handler
//-----------------------------------------------------------------------------
void handleCommand()
{
    char buffer[20];

    getsUart0(&data);
    parseFields(&data);

    if (isCommand(&data, "set", 2))
    {
        // Command: set <I_value> <Q_value>
        currentMode = MODE_STATIC;

        i_value = getFieldInteger(&data, 1);
        q_value = getFieldInteger(&data, 2);

        // Clamp to 12-bit range
        if (i_value < 0) i_value = 0;
        if (i_value > 4095) i_value = 4095;
        if (q_value < 0) q_value = 0;
        if (q_value > 4095) q_value = 4095;

        putsUart0("\rDAC values set: I=");
        intToStr(i_value, buffer);
        putsUart0(buffer);
        putsUart0(", Q=");
        intToStr(q_value, buffer);
        putsUart0(buffer);
        putsUart0("\n");
    }
    else if (isCommand(&data, "sine", 0))
    {
        // Command: sine - Generate 10 kHz sine wave
        currentMode = MODE_SINE;
        phase_accumulator = 0;

        // Calculate phase increment for 10 kHz
        // phase_increment = (10000 × 2^32) / 250000
        // = 10000 × 17180 = 171,800,000
        phase_increment = 10000 * 17180;

        TIMER1_TAILR_R = 320;  // 250 kHz sample rate
        putsUart0("\rSwitched to SINE wave mode (10 kHz)\n");
        putsUart0("\rI = cosine (0 deg), Q = sine (90 deg)\n");
    }
    else if (isCommand(&data, "static", 0))
    {
        // Command: static - Return to static mode
        currentMode = MODE_STATIC;
        putsUart0("\rSwitched to STATIC mode\n");
    }
    else if (isCommand(&data, "mid", 0))
    {
        // Command: mid - Set to mid-scale
        currentMode = MODE_STATIC;
        i_value = OFS_I;
        q_value = OFS_Q;
        putsUart0("\rSet to mid-scale (offset values)\n");
    }
    else if (isCommand(&data, "min", 0))
    {
        // Command: min - Set to minimum
        currentMode = MODE_STATIC;
        i_value = 0;
        q_value = 0;
        putsUart0("\rSet to minimum: I=0, Q=0\n");
    }
    else if (isCommand(&data, "max", 0))
    {
        // Command: max - Set to maximum
        currentMode = MODE_STATIC;
        i_value = 4095;
        q_value = 4095;
        putsUart0("\rSet to maximum: I=4095, Q=4095\n");
    }
    else if (isCommand(&data, "i", 1))
    {
        // Command: i <value> - Set I channel only
        currentMode = MODE_STATIC;
        i_value = getFieldInteger(&data, 1);
        if (i_value < 0) i_value = 0;
        if (i_value > 4095) i_value = 4095;

        putsUart0("\rI channel set to: ");
        intToStr(i_value, buffer);
        putsUart0(buffer);
        putsUart0("\n");
    }
    else if (isCommand(&data, "q", 1))
    {
        // Command: q <value> - Set Q channel only
        currentMode = MODE_STATIC;
        q_value = getFieldInteger(&data, 1);
        if (q_value < 0) q_value = 0;
        if (q_value > 4095) q_value = 4095;

        putsUart0("\rQ channel set to: ");
        intToStr(q_value, buffer);
        putsUart0(buffer);
        putsUart0("\n");
    }
    else if (isCommand(&data, "start", 0))
    {
        // Start continuous output
        TIMER1_CTL_R |= TIMER_CTL_TAEN;
        putsUart0("\rDAC output started\n");
    }
    else if (isCommand(&data, "stop", 0))
    {
        // Stop output
        TIMER1_CTL_R &= ~TIMER_CTL_TAEN;
        putsUart0("\rDAC output stopped\n");
    }
    else if (isCommand(&data, "freq", 1))
    {
        // Command: freq <Hz> - Set output frequency using phase accumulator
        uint32_t freq = getFieldInteger(&data, 1);

        // Phase accumulator method:
        // Sample rate = 250 kHz (fixed)
        // Phase increment = (Desired freq × 2^32) / Sample rate
        // LUT index = phase_accumulator >> 24 (top 8 bits)

        uint32_t sample_rate = 250000;  // 250 kHz

        if (freq < 1 || freq > 100000)
        {
            putsUart0("\rFrequency must be 1-100000 Hz\n");
            return;
        }

        // Calculate phase increment
        // phase_increment = (freq × 2^32) / sample_rate
        // To avoid overflow, rearrange: (freq × (2^32 / sample_rate))
        // 2^32 / 250000 = 17179.869 = 17180
        phase_increment = freq * 17180;

        putsUart0("\rFrequency set to: ");
        intToStr(freq, buffer);
        putsUart0(buffer);
        putsUart0(" Hz\n");

        // Calculate and show actual frequency
        uint32_t actual_freq = (phase_increment / 17180);
        putsUart0("\r(Actual: ");
        intToStr(actual_freq, buffer);
        putsUart0(buffer);
        putsUart0(" Hz)\n");
    }
    else if (isCommand(&data, "help", 0))
    {
        putsUart0("\n=== CSE-4377 Lab 1 Commands ===\n");
        putsUart0("\rset <I> <Q>  - Set both channels (0-4095)\n");
        putsUart0("\ri <value>    - Set I channel only (0-4095)\n");
        putsUart0("\rq <value>    - Set Q channel only (0-4095)\n");
        putsUart0("\rmid          - Set to calibrated mid-scale\n");
        putsUart0("\rmin          - Set to minimum (0, 0)\n");
        putsUart0("\rmax          - Set to maximum (4095, 4095)\n");
        putsUart0("\rsine         - Generate 10 kHz sine wave\n");
        putsUart0("\rstatic       - Return to static mode\n");
        putsUart0("\rfreq <Hz>    - Set sine frequency (1-100000 Hz)\n");
        putsUart0("\rstart        - Start DAC output\n");
        putsUart0("\rstop         - Stop DAC output\n");
        putsUart0("\rhelp         - Show this help\n\n");
        putsUart0("\rCalibration values:\n");
        putsUart0("\r  GAIN_I=");
        intToStr(GAIN_I, buffer);
        putsUart0(buffer);
        putsUart0("\r, GAIN_Q=");
        intToStr(GAIN_Q, buffer);
        putsUart0(buffer);
        putsUart0("\n  OFS_I=");
        intToStr(OFS_I, buffer);
        putsUart0(buffer);
        putsUart0("\r, OFS_Q=");
        intToStr(OFS_Q, buffer);
        putsUart0(buffer);
        putsUart0("\n\n");
    }
    else
    {
        putsUart0("\rUnknown command. Type 'help' for options.\n");
    }
}

//-----------------------------------------------------------------------------
// Hardware Initialization
//-----------------------------------------------------------------------------
void initHW()
{
    // Initialize system clock to 80 MHz
    initSystemClockTo80Mhz();

    // Enable Ports
    SYSCTL_RCGCTIMER_R |= SYSCTL_RCGCTIMER_R1;
    enablePort(PORTC);
    enablePort(PORTD);

    // Enable Timer
    // For sine wave generation, use fixed 250 kHz sample rate
    // Timer period = 80MHz / 250kHz = 320
    TIMER1_CTL_R &= ~TIMER_CTL_TAEN;                 // Turn off timer
    TIMER1_CFG_R = TIMER_CFG_32_BIT_TIMER;           // 32-bit timer
    TIMER1_TAMR_R = TIMER_TAMR_TAMR_PERIOD;          // Periodic mode
    TIMER1_TAILR_R = 320;                            // 250 kHz sample rate
    TIMER1_IMR_R = TIMER_IMR_TATOIM;                 // Enable interrupts
    NVIC_EN0_R = 1 << (INT_TIMER1A-16);              // Enable interrupt 37

    // Configure LDAC pin
    selectPinPushPullOutput(PORTC, 4);

    // Initialize SPI
    initSpi1(USE_SSI_FSS);
    setSpi1BaudRate(FDAC, 80e6);
}

//-----------------------------------------------------------------------------
// Main
//-----------------------------------------------------------------------------
int main(void)
{
    // Initialize hardware
    initHW();
    initUart0();
    setUart0BaudRate(115200, 80e6);

    // Generate lookup tables
    generateLUT();

    // Startup message
    putsUart0("\n\n");
    putsUart0("\r========================================\n");
    putsUart0("\r  CSE-4377 Lab 1 - IQ Modulation\n");
    putsUart0("\r========================================\n");
    putsUart0("\nType 'help' for available commands\n");
    putsUart0("\rType 'start' to begin DAC output\n");
    putsUart0("\rType 'sine' for 10 kHz test tone\n\n");

    // Main loop
    while (true)
    {
        if (kbhitUart0())
        {
            handleCommand();
        }
    }
}
